Origin: https://savannah.nongnu.org/bugs/?46346
Last-Update: 2019-09-03
Reviewed-by: Sylvain Beucler <beuc@debian.org>

commit 57cbb8c148999ba8f14ed53435fc071ac9953afd
Author: Werner Lemberg <wl@gnu.org>
Date:   Sat Oct 31 18:47:26 2015 +0100

    [sfnt] Fix cmap 14 validation (#46346).
    
    * src/sfnt/ttcmap.c (tt_cmap14_validate): Check limit before
    accessing `numRanges' and `numMappings'.
    Fix size check for non-default UVS table.

Index: freetype-2.5.2/src/sfnt/ttcmap.c
===================================================================
--- freetype-2.5.2.orig/src/sfnt/ttcmap.c
+++ freetype-2.5.2/src/sfnt/ttcmap.c
@@ -2813,12 +2813,17 @@
         /* through the normal Unicode cmap, no GIDs, just check order) */
         if ( defOff != 0 )
         {
-          FT_Byte*  defp      = table + defOff;
-          FT_ULong  numRanges = TT_NEXT_ULONG( defp );
+          FT_Byte*  defp     = table + defOff;
+          FT_ULong  numRanges;
           FT_ULong  i;
-          FT_ULong  lastBase  = 0;
+          FT_ULong  lastBase = 0;
 
 
+          if ( defp + 4 > valid->limit )
+            FT_INVALID_TOO_SHORT;
+
+          numRanges = TT_NEXT_ULONG( defp );
+
           /* defp + numRanges * 4 > valid->limit ? */
           if ( numRanges > (FT_ULong)( valid->limit - defp ) / 4 )
             FT_INVALID_TOO_SHORT;
@@ -2842,13 +2847,18 @@
         /* and the non-default table (these glyphs are specified here) */
         if ( nondefOff != 0 )
         {
-          FT_Byte*  ndp         = table + nondefOff;
-          FT_ULong  numMappings = TT_NEXT_ULONG( ndp );
-          FT_ULong  i, lastUni  = 0;
+          FT_Byte*  ndp        = table + nondefOff;
+          FT_ULong  numMappings;
+          FT_ULong  i, lastUni = 0;
+
+
+          if ( ndp + 4 > valid->limit )
+            FT_INVALID_TOO_SHORT;
 
+          numMappings = TT_NEXT_ULONG( ndp );
 
-          /* numMappings * 4 > (FT_ULong)( valid->limit - ndp ) ? */
-          if ( numMappings > ( (FT_ULong)( valid->limit - ndp ) ) / 4 )
+          /* numMappings * 5 > (FT_ULong)( valid->limit - ndp ) ? */
+          if ( numMappings > ( (FT_ULong)( valid->limit - ndp ) ) / 5 )
             FT_INVALID_TOO_SHORT;
 
           for ( i = 0; i < numMappings; ++i )
